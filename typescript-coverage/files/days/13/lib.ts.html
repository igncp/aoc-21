
  <!DOCTYPE html>
  <html>
    <head>
      <title>lib.ts</title>
      <link href="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css" type="text/css" rel="stylesheet">
      <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.js" type="text/javascript" charset="utf-8"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/mode/javascript/javascript.min.js" type="text/javascript" charset="utf-8"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.css" type="text/css" rel="stylesheet">
<script src="../../../assets/source-file.js" type="text/javascript" charset="utf-8"></script>
<link href="../../../assets/source-file.css" type="text/css" rel="stylesheet">
    </head>
    <body>
    <div style="margin-top:3em" class="ui container"><h1 class="ui header"><a href="../../../index.html">TypeScript coverage report</a></h1><table style="margin-top:2em" class="ui celled table"><thead class=""><tr class=""><th class="">Filename</th><th class="">Percent</th><th class="">Threshold</th><th class="">Total</th><th class="">Covered</th><th class="">Uncovered</th></tr></thead><tbody class=""><tr class="positive"><td class="">days/13/lib.ts</td><td class="">100.00%</td><td class="">99%</td><td class="">188</td><td class="">188</td><td class="">0</td></tr></tbody></table><textarea id="editor" readonly="" style="margin-top:3em">enum FoldType {
  Horizontal = &quot;horizontal&quot;,
  Vertical = &quot;vertical&quot;,
}

class Origami {
  private readonly points: Set&lt;string&gt;
  private readonly folds: Array&lt;{ axis: FoldType; position: number }&gt;

  public constructor(setupStr: string) {
    const [initialPointsStr, foldsStr] = setupStr.split(&quot;\n\n&quot;)
    const pointsArr = initialPointsStr.split(&quot;\n&quot;).filter((v) =&gt; !!v)

    this.points = new Set(pointsArr)

    this.folds = foldsStr
      .split(&quot;\n&quot;)
      .filter((v) =&gt; !!v)
      .map((line) =&gt; {
        const [axis, numStr] = line.replace(&quot;fold along &quot;, &quot;&quot;).split(&quot;=&quot;)

        return {
          axis: axis === &quot;y&quot; ? FoldType.Horizontal : FoldType.Vertical,
          position: Number(numStr),
        }
      })
  }

  public performAllFolds() {
    this.foldNTimes(this.folds.length)
  }

  public foldNTimes(foldsNumber: number) {
    const { folds, points } = this

    for (let foldIndex = 0; foldIndex &lt; foldsNumber; foldIndex += 1) {
      const fold = folds.shift()!

      if (fold.axis === FoldType.Horizontal) {
        Array.from(points).forEach((pointStr) =&gt; {
          const point = pointStr.split(&quot;,&quot;).map(Number)

          if (point[1] &gt; fold.position) {
            point[1] -= (point[1] - fold.position) * 2
            points.delete(pointStr)
            points.add(point.join(&quot;,&quot;))
          }
        })
      } else {
        Array.from(points).forEach((pointStr) =&gt; {
          const point = pointStr.split(&quot;,&quot;).map(Number)

          if (point[0] &gt; fold.position) {
            point[0] -= (point[0] - fold.position) * 2
            points.delete(pointStr)
            points.add(point.join(&quot;,&quot;))
          }
        })
      }
    }
  }

  public getVisibleDots() {
    return this.points.size
  }

  public paintMap() {
    const { points } = this

    const minMax = Array.from(this.points).reduce(
      (...[acc, pointStr]) =&gt; {
        const point = pointStr.split(&quot;,&quot;).map(Number)

        acc[0][0] = Math.min(acc[0][0], point[0])
        acc[0][1] = Math.min(acc[0][1], point[1])
        acc[1][0] = Math.max(acc[1][0], point[0])
        acc[1][1] = Math.max(acc[1][1], point[1])

        return acc
      },
      [
        [0, 0],
        [0, 0],
      ]
    )

    const lines = []

    for (let y = minMax[0][1] - 1; y &lt;= minMax[1][1] + 1; y += 1) {
      const line = []

      for (let x = minMax[0][0] - 1; x &lt;= minMax[1][0] + 1; x += 1) {
        const point = [x, y].join(&quot;,&quot;)

        if (points.has(point)) {
          line.push(&quot;#&quot;)
        } else {
          line.push(&quot;.&quot;)
        }
      }

      lines.push(line.join(&quot;&quot;))
    }

    return lines.join(&quot;\n&quot;)
  }
}

export { Origami }
</textarea><pre id="annotations" style="display:none">[]</pre></div>
    <p class="footer-text">TypeScript Coverage Report generated by <a href="https://github.com/plantain-00/type-coverage">type-coverage</a> and <a href="https://github.com/alexcanessa/typescript-coverage-report">typescript-coverage-report</a> at Sun, 02 Jan 2022 19:37:32 GMT</p>
    </body>
  </html>
  