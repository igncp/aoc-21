
  <!DOCTYPE html>
  <html>
    <head>
      <title>lib.ts</title>
      <link href="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css" type="text/css" rel="stylesheet">
      <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.js" type="text/javascript" charset="utf-8"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/mode/javascript/javascript.min.js" type="text/javascript" charset="utf-8"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.css" type="text/css" rel="stylesheet">
<script src="../../../assets/source-file.js" type="text/javascript" charset="utf-8"></script>
<link href="../../../assets/source-file.css" type="text/css" rel="stylesheet">
    </head>
    <body>
    <div style="margin-top:3em" class="ui container"><h1 class="ui header"><a href="../../../index.html">TypeScript coverage report</a></h1><table style="margin-top:2em" class="ui celled table"><thead class=""><tr class=""><th class="">Filename</th><th class="">Percent</th><th class="">Threshold</th><th class="">Total</th><th class="">Covered</th><th class="">Uncovered</th></tr></thead><tbody class=""><tr class="positive"><td class="">days/16/lib.ts</td><td class="">100.00%</td><td class="">99%</td><td class="">413</td><td class="">413</td><td class="">0</td></tr></tbody></table><textarea id="editor" readonly="" style="margin-top:3em">import { Readable } from &quot;node:stream&quot;
import { Observable, from, mergeMap, of, reduce } from &quot;rxjs&quot;

enum PacketType {
  Equal = &quot;equal&quot;,
  Greater = &quot;greater&quot;,
  Less = &quot;less&quot;,
  Literal = &quot;literal&quot;,
  Maximum = &quot;maximum&quot;,
  Minimum = &quot;minimum&quot;,
  Multiply = &quot;multiply&quot;,
  Sum = &quot;sum&quot;,
}

const typeIdToTypeValue = [
  PacketType.Sum,
  PacketType.Multiply,
  PacketType.Minimum,
  PacketType.Maximum,
  PacketType.Literal,
  PacketType.Greater,
  PacketType.Less,
  PacketType.Equal,
]

type LiteralPacket = {
  content: number
  type: PacketType.Literal
  version: number
}

type OperatorPacket = {
  subpackets: Packet[] // eslint-disable-line @typescript-eslint/no-use-before-define
  type:
    | PacketType.Equal
    | PacketType.Greater
    | PacketType.Less
    | PacketType.Maximum
    | PacketType.Minimum
    | PacketType.Multiply
    | PacketType.Sum
  version: number
}

type Packet = LiteralPacket | OperatorPacket

enum State {
  CollectingSubpackets = &quot;subpackets&quot;,
  CollectingSubpacketsLength = &quot;subpackets-length&quot;,
  Head = &quot;head&quot;,
  LiteralContent = &quot;literal&quot;,
}

enum LengthType {
  Bits = &quot;bits&quot;,
  Count = &quot;count&quot;,
}

const hex2bin = (hexLetter: string) =&gt;
  parseInt(hexLetter, 16).toString(2).padStart(4, &quot;0&quot;)

class BITSProtocol {
  private packets: Packet[] = []
  private readonly bits: Observable&lt;number&gt;

  public constructor(rawInput: Readable | string) {
    this.bits = (
      typeof rawInput === &quot;string&quot; ? of(rawInput) : from(rawInput)
    ).pipe(
      mergeMap((str: Buffer | string) =&gt; {
        return str
          .toString()
          .split(&quot;&quot;)
          .filter((v) =&gt; !!v)
          .reduce&lt;number[]&gt;((...[bits, hexLetter]) =&gt; {
            const subBits = hex2bin(hexLetter).split(&quot;&quot;).map(Number)

            bits.push(...subBits)

            return bits
          }, [])
      })
    )
  }

  public static evaluatePackets(packets: Packet[]) {
    const operationResult = (packet: Packet): number =&gt; {
      switch (packet.type) {
        case PacketType.Literal:
          return packet.content

        case PacketType.Sum: {
          return packet.subpackets.reduce((...[total, subpacket]) =&gt; {
            return total + operationResult(subpacket)
          }, 0)
        }

        case PacketType.Multiply: {
          return packet.subpackets.reduce((...[total, subpacket]) =&gt; {
            return total * operationResult(subpacket)
          }, 1)
        }

        case PacketType.Minimum: {
          return packet.subpackets.reduce((...[total, subpacket]) =&gt; {
            return Math.min(total, operationResult(subpacket))
          }, Infinity)
        }

        case PacketType.Maximum: {
          return packet.subpackets.reduce((...[total, subpacket]) =&gt; {
            return Math.max(total, operationResult(subpacket))
          }, 0)
        }

        case PacketType.Greater: {
          return operationResult(packet.subpackets[0]) &gt;
            operationResult(packet.subpackets[1])
            ? 1
            : 0
        }

        case PacketType.Less: {
          return operationResult(packet.subpackets[0]) &lt;
            operationResult(packet.subpackets[1])
            ? 1
            : 0
        }

        case PacketType.Equal: {
          return operationResult(packet.subpackets[0]) ===
            operationResult(packet.subpackets[1])
            ? 1
            : 0
        }

        default:
          throw new Error(&quot;Unknown packet type&quot;)
      }
    }

    return packets.reduce((...[sum, packet]) =&gt; {
      return sum + operationResult(packet)
    }, 0)
  }

  private static decodePackets({
    bits,
    maxPackets,
  }: {
    bits: number[]
    maxPackets: number | null
  }) {
    const packets: Packet[] = []
    const literalContentBits: number[] = []

    let packetPosition = 0
    let subBits = &quot;&quot;
    let packet: Partial&lt;Packet&gt; = {}
    let subpacketsLength = 0
    let bitsCount = 0
    let skipBits = 0

    let { Head: state }: { Head: State } = State
    let { Bits: lengthType }: { Bits: LengthType } = LengthType

    const savePacket = () =&gt; {
      packets.push(packet as Packet)
      packetPosition = 0
    }

    bits.forEach((...[bit, bitIndex]) =&gt; {
      if (typeof maxPackets === &quot;number&quot; &amp;&amp; maxPackets === packets.length) {
        return
      }

      if (skipBits) {
        skipBits -= 1

        return
      }

      bitsCount += 1
      subBits += bit

      switch (true) {
        case packetPosition === 0: {
          packet = {}
          literalContentBits.length = 0
          state = State.Head
          subBits = bit.toString()
          break
        }

        case packetPosition === 2: {
          packet.version = parseInt(subBits, 2)
          subBits = &quot;&quot;
          break
        }

        case packetPosition === 5: {
          const typeId = parseInt(subBits, 2)

          packet.type = typeIdToTypeValue[typeId]
          subBits = &quot;&quot;
          break
        }

        case packetPosition === 6: {
          if (packet.type === PacketType.Literal) {
            state = State.LiteralContent
          } else {
            if (subBits === &quot;0&quot;) {
              lengthType = LengthType.Bits
            } else {
              lengthType = LengthType.Count
            }

            state = State.CollectingSubpacketsLength
            subBits = &quot;&quot;
          }

          break
        }
      }

      if (
        state === State.CollectingSubpacketsLength &amp;&amp;
        subBits.length === (lengthType === LengthType.Bits ? 15 : 11)
      ) {
        subpacketsLength = parseInt(subBits, 2)

        if (lengthType === LengthType.Bits) {
          state = State.CollectingSubpackets
          subBits = &quot;&quot;
        } else {
          const { bitsCount: newBitsCount, packets: subpackets } =
            BITSProtocol.decodePackets({
              bits: bits.slice(bitIndex + 1, bits.length),
              maxPackets: subpacketsLength,
            })

          ;(packet as OperatorPacket).subpackets = subpackets
          savePacket()

          skipBits = newBitsCount
          bitsCount += newBitsCount

          return
        }
      }

      if (
        state === State.CollectingSubpackets &amp;&amp;
        subBits.length === subpacketsLength
      ) {
        const { packets: subpackets } = BITSProtocol.decodePackets({
          bits: subBits.split(&quot;&quot;).map(Number),
          maxPackets: null,
        })

        ;(packet as OperatorPacket).subpackets = subpackets

        savePacket()

        return
      }

      if (state === State.LiteralContent &amp;&amp; subBits.length === 5) {
        const [shouldContinue, ...newContentBits] = subBits
          .split(&quot;&quot;)
          .map(Number)

        literalContentBits.push(...newContentBits)

        subBits = &quot;&quot;

        if (shouldContinue === 0) {
          ;(packet as LiteralPacket).content = parseInt(
            literalContentBits.join(&quot;&quot;),
            2
          )
          savePacket()

          return
        }
      }

      packetPosition += 1
    })

    return {
      bitsCount,
      packets,
    }
  }

  public decodeAllPackets() {
    const { bits } = this

    return new Promise&lt;void&gt;((resolve) =&gt; {
      bits
        .pipe(
          reduce((...[collectedBits, bit]) =&gt; {
            return collectedBits.concat([bit])
          }, [] as number[])
        )
        .subscribe((allBits) =&gt; {
          this.packets = BITSProtocol.decodePackets({
            bits: allBits,
            maxPackets: null,
          }).packets

          resolve()
        })
    })
  }

  public evaluatePackets() {
    return BITSProtocol.evaluatePackets(this.packets)
  }

  public getPackets() {
    return this.packets.slice()
  }

  public getRecursiveVersionSum() {
    const recursiveReduce = (...[sum, packet]: [number, Packet]): number =&gt; {
      return (
        sum +
        packet.version +
        (&quot;subpackets&quot; in packet ? packet.subpackets : []).reduce(
          recursiveReduce,
          0
        )
      )
    }

    return this.packets.reduce(recursiveReduce, 0)
  }
}

export { BITSProtocol, PacketType, Packet }
</textarea><pre id="annotations" style="display:none">[]</pre></div>
    <p class="footer-text">TypeScript Coverage Report generated by <a href="https://github.com/plantain-00/type-coverage">type-coverage</a> and <a href="https://github.com/alexcanessa/typescript-coverage-report">typescript-coverage-report</a> at Fri, 07 Jan 2022 00:17:55 GMT</p>
    </body>
  </html>
  