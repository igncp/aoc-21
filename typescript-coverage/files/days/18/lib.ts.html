
  <!DOCTYPE html>
  <html>
    <head>
      <title>lib.ts</title>
      <link href="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css" type="text/css" rel="stylesheet">
      <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.js" type="text/javascript" charset="utf-8"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/mode/javascript/javascript.min.js" type="text/javascript" charset="utf-8"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.css" type="text/css" rel="stylesheet">
<script src="../../../assets/source-file.js" type="text/javascript" charset="utf-8"></script>
<link href="../../../assets/source-file.css" type="text/css" rel="stylesheet">
    </head>
    <body>
    <div style="margin-top:3em" class="ui container"><h1 class="ui header"><a href="../../../index.html">TypeScript coverage report</a></h1><table style="margin-top:2em" class="ui celled table"><thead class=""><tr class=""><th class="">Filename</th><th class="">Percent</th><th class="">Threshold</th><th class="">Total</th><th class="">Covered</th><th class="">Uncovered</th></tr></thead><tbody class=""><tr class="positive"><td class="">days/18/lib.ts</td><td class="">100.00%</td><td class="">99%</td><td class="">727</td><td class="">727</td><td class="">0</td></tr></tbody></table><textarea id="editor" readonly="" style="margin-top:3em">type RecursiveArray&lt;T&gt; = Array&lt;RecursiveArray&lt;T&gt;&gt; | T
type RecursiveNumArray = RecursiveArray&lt;number&gt;

type BaseNode = {
  depth: number
  id: number
  leaf?: number
  parent: BaseNode[&quot;id&quot;] | null
  path: number[]
}
type TreeNode = BaseNode &amp; {
  children?: Array&lt;TreeNode[&quot;id&quot;]&gt;
}
type TreeNodeFull = BaseNode &amp; {
  children?: TreeNodeFull[]
}

type Tree = {
  [key: TreeNode[&quot;id&quot;]]: TreeNode
}

enum Side {
  Left = &quot;left&quot;,
  Right = &quot;right&quot;,
}

class SnailfishNumber {
  private readonly tree: Tree

  public constructor(numDefinition: Tree | string) {
    this.tree =
      typeof numDefinition === &quot;string&quot;
        ? SnailfishNumber.fromString(numDefinition)
        : numDefinition
  }

  public static sumAll(list: string): SnailfishNumber {
    const snailfishList = list
      .split(&quot;\n&quot;)
      .filter((line) =&gt; !!line.trim())
      .map((line) =&gt; new SnailfishNumber(line))

    return snailfishList
      .slice(1)
      .reduce((...[accNumberSnailfish, snailfishNumber]) =&gt; {
        const newNumber = accNumberSnailfish.add(snailfishNumber)

        newNumber.reduce()

        return newNumber
      }, snailfishList[0])
  }

  public static getHighestMagnitude(list: string): number {
    const snailfishList = list
      .split(&quot;\n&quot;)
      .filter((line) =&gt; !!line.trim())
      .map((line) =&gt; new SnailfishNumber(line))

    let maxMagnitude = 0

    snailfishList.forEach((...[numberA, numberAIndex]) =&gt; {
      snailfishList.forEach((...[numberB, numberBIndex]) =&gt; {
        if (numberAIndex === numberBIndex) {
          return
        }

        const newNumber = numberA.add(numberB)

        newNumber.reduce()

        const newMagnitude = newNumber.getMagnitude()

        if (maxMagnitude &lt; newMagnitude) {
          maxMagnitude = newMagnitude
        }
      })
    })

    return maxMagnitude
  }

  private static fromString(numDefinition: string): Tree {
    const numsArray: RecursiveNumArray = JSON.parse(numDefinition)
    let currentId = 0

    const recursiveFn = ({
      depth,
      nodeArr,
      parentId,
      path,
    }: {
      depth: number
      nodeArr: RecursiveNumArray | number
      parentId: TreeNode[&quot;id&quot;] | null
      path: number[]
    }): TreeNodeFull =&gt; {
      currentId += 1

      const id = currentId

      return {
        depth,
        id: currentId,
        parent: parentId,
        path,
        ...(Array.isArray(nodeArr)
          ? {
              children: nodeArr.map((...[subItem, subItemIndex]) =&gt;
                recursiveFn({
                  depth: depth + 1,
                  nodeArr: subItem,
                  parentId: id,
                  path: path.concat(subItemIndex),
                })
              ),
            }
          : { leaf: nodeArr }),
      }
    }

    const fullTree = recursiveFn({
      depth: 0,
      nodeArr: numsArray,
      parentId: null,
      path: [],
    })

    const recursiveReduce = (...[tree, nodeFull]: [Tree, TreeNodeFull]) =&gt; {
      const node: TreeNode =
        &quot;children&quot; in nodeFull
          ? ({
              ...nodeFull,
              children: nodeFull.children!.map((c) =&gt; c.id),
            } as TreeNode)
          : ({ ...nodeFull } as TreeNode)

      if (&quot;children&quot; in nodeFull) {
        nodeFull.children!.forEach((c) =&gt; {
          recursiveReduce(tree, c)
        })
      }

      tree[node.id] = node

      return tree
    }

    const tree = [fullTree].reduce&lt;Tree&gt;(recursiveReduce, {})

    return tree
  }

  public add(otherNum: SnailfishNumber): SnailfishNumber {
    const maxId = this.getMaxId() + 2 // +1 will be the new root
    const rootNode = this.getRootNode()
    const rootNodeOther = otherNum.getRootNode()
    const thisTree = Object.keys(this.tree).reduce(
      (...[thisTreeAcc, thisTreeKey]: [Tree, string]) =&gt; {
        const numKey = Number(thisTreeKey)

        const newNode = {
          ...this.tree[numKey],
        }

        thisTreeAcc[numKey] = newNode
        newNode.path = newNode.path.slice()
        newNode.path.unshift(0)

        return thisTreeAcc
      },
      {}
    )
    const otherTree = Object.keys(otherNum.tree).reduce&lt;Tree&gt;(
      (...[otherTreeAcc, otherTreeKey]: [Tree, string]) =&gt; {
        const numKey = Number(otherTreeKey)

        const newId = numKey + maxId
        const newNode = {
          ...otherNum.tree[numKey],
          id: newId,
        }

        otherTreeAcc[newId] = newNode
        newNode.path = newNode.path.slice()
        newNode.path.unshift(1)
        newNode.parent = newNode.parent ? newNode.parent + maxId : null

        if (&quot;children&quot; in newNode) {
          newNode.children = newNode.children!.map((c) =&gt; c + maxId)
        }

        return otherTreeAcc
      },
      {}
    )

    const newTree = { ...thisTree, ...otherTree }

    Object.keys(newTree).forEach((newTreeKey) =&gt; {
      const numKey = Number(newTreeKey)

      newTree[numKey] = {
        ...newTree[numKey],
        depth: newTree[numKey].depth + 1,
      }
    })

    const newRootId = maxId - 1
    const newRootOtherId = rootNodeOther.id + maxId

    newTree[newRootId] = {
      children: [rootNode.id, newRootOtherId],
      depth: 0,
      id: newRootId,
      parent: null,
      path: [],
    }

    newTree[rootNode.id] = { ...newTree[rootNode.id], parent: newRootId }
    newTree[newRootOtherId] = { ...newTree[newRootOtherId], parent: newRootId }

    return new SnailfishNumber(newTree)
  }

  public getMagnitude() {
    const rootNode = this.getRootNode()

    const recursiveReduce = (node: TreeNode): number =&gt; {
      if (&quot;children&quot; in node) {
        return node.children!.reduce((...[subAcc, childId, childIndex]) =&gt; {
          const {
            tree: { [childId]: child },
          } = this

          const childVal = recursiveReduce(child)

          return subAcc + (childIndex === 0 ? childVal * 3 : childVal * 2)
        }, 0)
      }

      return node.leaf!
    }

    return recursiveReduce(rootNode)
  }

  public explode() {
    const nodeId = Object.keys(this.tree)
      .filter((treeKey) =&gt; {
        const numKey = Number(treeKey)

        return this.tree[numKey].depth &gt;= 4 &amp;&amp; !!this.tree[numKey].children
      })
      .sort(this.sortByPath)[0]

    if (!nodeId) {
      return false
    }

    const nodeIdNum = Number(nodeId)

    const {
      tree: { [nodeIdNum]: node },
    } = this

    const nodeValues = node.children!.map((c) =&gt; {
      return this.tree[c].leaf!
    })

    node.children!.forEach((c) =&gt; {
      delete this.tree[c]
    })
    delete node.children
    node.leaf = 0

    const leftNode = this.getLeftNode(nodeIdNum)

    if (leftNode) {
      leftNode.leaf! += nodeValues[0]
    }

    const rightNode = this.getRightNode(nodeIdNum)

    if (rightNode) {
      rightNode.leaf! += nodeValues[1]
    }

    return true
  }

  public split() {
    const maxId = this.getMaxId()
    const nodeId = Object.keys(this.tree)
      .filter((treeKey) =&gt; {
        const numKey = Number(treeKey)

        return &quot;leaf&quot; in this.tree[numKey] &amp;&amp; this.tree[numKey].leaf! &gt;= 10
      })
      .sort(this.sortByPath)[0]

    if (!nodeId) {
      return false
    }

    const nodeIdNum = Number(nodeId)
    const {
      tree: { [nodeIdNum]: node },
    } = this
    const halfLeaf = node.leaf! / 2
    const [newLeft, newRight] = [Math.floor(halfLeaf), Math.ceil(halfLeaf)]

    delete node.leaf

    const nodeLeft = {
      depth: node.depth + 1,
      id: maxId + 1,
      leaf: newLeft,
      parent: nodeIdNum,
      path: node.path.concat([0]),
    }
    const nodeRight = {
      depth: node.depth + 1,
      id: maxId + 2,
      leaf: newRight,
      parent: nodeIdNum,
      path: node.path.concat([1]),
    }

    node.children = [nodeLeft.id, nodeRight.id]
    this.tree[nodeLeft.id] = nodeLeft
    this.tree[nodeRight.id] = nodeRight

    return true
  }

  public toString(): string {
    const rootNode = this.getRootNode()

    return this.toStringNode(rootNode)
  }

  public reduce(maxStep = -1) {
    let didChange = true
    let steps = 0

    while (didChange &amp;&amp; (maxStep &lt; 0 || steps &lt; maxStep)) {
      steps += 1

      didChange = false
      didChange = this.explode()

      if (didChange) {
        continue
      }

      didChange = this.split()
    }
  }

  private getLeftNode(nodeId: number) {
    return this.getSideNode({ nodeId, side: Side.Left })
  }

  private getRightNode(nodeId: number) {
    return this.getSideNode({ nodeId, side: Side.Right })
  }

  private getSideNode({
    nodeId,
    side,
  }: {
    nodeId: number
    side: Side
  }): TreeNode | null {
    let {
      tree: { [nodeId]: node },
    } = this
    // eslint-disable-next-line prefer-destructuring
    let parent: TreeNode | null = this.tree[node.parent!]

    while (
      parent &amp;&amp;
      parent.children!.indexOf(node.id) !== (side === Side.Left ? 1 : 0)
    ) {
      node = this.tree[parent.id]
      parent = node.parent ? this.tree[node.parent] : null
    }

    if (!parent) {
      return null
    }

    const { [side === Side.Left ? 0 : 1]: newNodeId } =
      this.tree[parent.id].children!

    node = this.tree[Number(newNodeId)]

    while (node.children) {
      node = this.tree[node.children[side === Side.Left ? 1 : 0]]
    }

    return node
  }

  private toStringNode(rootNode: TreeNode): string {
    const recursiveFn = (node: TreeNode): RecursiveNumArray =&gt; {
      return &quot;children&quot; in node
        ? node.children!.map((c) =&gt; recursiveFn(this.tree[c]))
        : node.leaf!
    }

    const numsArray = recursiveFn(rootNode)

    return JSON.stringify(numsArray, null, 0)
  }

  private getRootNode() {
    const firstId = Number(Object.keys(this.tree)[0]!)
    let {
      tree: {
        [firstId]: { id, parent },
      },
    } = this

    while (parent) {
      id = this.tree[parent].id
      parent = this.tree[parent].parent
    }

    return this.tree[id]
  }

  private getMaxId() {
    return Math.max(...Object.keys(this.tree).map(Number))
  }

  private readonly sortByPath = (...[nodeIdA, nodeIdB]: [string, string]) =&gt; {
    const {
      tree: { [Number(nodeIdA)]: nodeA, [Number(nodeIdB)]: nodeB },
    } = this

    for (let pathAIndex = 0; pathAIndex &lt; nodeA.path.length; pathAIndex += 1) {
      const {
        path: { [pathAIndex]: pathAElement },
      } = nodeA
      const {
        path: { [pathAIndex]: pathBElement },
      } = nodeB

      if (pathAElement !== pathBElement) {
        return pathAElement - pathBElement
      }
    }

    /* istanbul ignore next */
    return nodeA.path.length - nodeB.path.length
  }
}

export { SnailfishNumber }
</textarea><pre id="annotations" style="display:none">[]</pre></div>
    <p class="footer-text">TypeScript Coverage Report generated by <a href="https://github.com/plantain-00/type-coverage">type-coverage</a> and <a href="https://github.com/alexcanessa/typescript-coverage-report">typescript-coverage-report</a> at Sat, 19 Feb 2022 18:27:16 GMT</p>
    </body>
  </html>
  